extern crate core;

mod extract;
mod mine;

use extract::*;
use mine::*;
use std::collections::{HashMap, HashSet};

use clap::{Arg, ArgMatches, Command};
use json_comments::StripComments;
use serde::{Deserialize, Serialize};

use std::fs::File;
use std::io::Write;
use std::time::Instant;

enum MinerCmd {
    Extract(ExtractArgs),
    Mine(MineArgs),
    Diff(DiffArgs),
}

struct ExtractArgs {
    file_names: Vec<String>,
    output: String,
    id: String,
}

struct MineArgs {
    file_names: Vec<String>,
    output: Option<String>,
    assert_instead_of_cover: bool,
    filters: SignalFilters,
    max_holes: TemplateSize,
    signal_info: Option<String>,
}

struct DiffArgs {
    base_filename: Option<String>,
    a_filename: String,
    a_name: String,
    b_filename: String,
    b_name: String,
    filters: SignalFilters,
    max_holes: TemplateSize,
    output: Option<String>,
    signal_info: Option<String>,
}

fn parse_filters(matches: &ArgMatches, always_include_stuck: bool) -> SignalFilters {
    let include_stuck_signals = matches.is_present("include-stuck") || always_include_stuck;
    let include_signals: Vec<String> = matches
        .value_of("include")
        .map(|f| {
            let file = File::open(f).expect("Failed to open include list.");
            let stripped = StripComments::new(file);
            serde_json::from_reader(stripped).expect("Failed to parse include list.")
        })
        .unwrap_or_default();
    let user_exclude_signals: Vec<String> = matches
        .value_of("exclude")
        .map(|f| {
            let file = File::open(f).expect("Failed to open exclude list.");
            let stripped = StripComments::new(file);
            serde_json::from_reader(stripped).expect("Failed to parse exclude list.")
        })
        .unwrap_or_default();
    assert!(
        include_signals.is_empty() || user_exclude_signals.is_empty(),
        "Cannot include and exclude signals at the same time!"
    );
    SignalFilters {
        include_stuck_signals,
        user_exclude_signals,
        include_signals,
    }
}

fn parse_max_holes(matches: &ArgMatches) -> TemplateSize {
    let max_holes_str = matches.value_of("max-holes").unwrap_or("3");
    let max_holes = match max_holes_str.to_lowercase().trim() {
        "1" => TemplateSize::One,
        "2" => TemplateSize::Two,
        "3" => TemplateSize::Three,
        other => panic!(
            "Invalid max-holes parameter value: {}. Try 1 or 2 or 3.",
            other
        ),
    };
    max_holes
}

fn parse_args() -> MinerCmd {
    let extract_cmd = Command::new("extract")
        .about("extract tracker signals from VCDs and export them to JSON")
        .arg(
            Arg::new("output")
                .long("output")
                .short('o')
                .help("output json containing traces")
                .takes_value(true),
        )
        .arg(Arg::new("inputs").multiple_occurrences(true).required(true))
        .arg(
            Arg::new("id")
                .long("id")
                .takes_value(true)
                .required(true)
                .help("id describing the values"),
        );
    let mine_cmd = Command::new("mine")
        .about("mine properties from a set of traces")
        .arg(
            Arg::new("output")
                .long("output")
                .short('o')
                .help("output file for mined invariants")
                .takes_value(true),
        )
        .arg(Arg::new("inputs").multiple_occurrences(true))
        .arg(
            Arg::new("assert")
                .long("assert")
                .help("generate assert instead of cover statements"),
        )
        .arg(
            Arg::new("include")
                .long("include")
                .short('i')
                .takes_value(true)
                .help("JSON include list for which signals we should track"),
        )
        .arg(
            Arg::new("exclude")
                .long("exclude")
                .short('e')
                .takes_value(true)
                .help("JSON exclude list for which signals we should track"),
        )
        .arg(
            Arg::new("max-holes")
                .long("max-holes")
                .takes_value(true)
                .help("maximum number of holes in the assertion templates: 1 or 2 or 3"),
        )
        .arg(
            Arg::new("include-stuck")
                .long("include-stuck")
                .help("include signals stuck at 1 or 0 in the assertion mining"),
        )
        .arg(
            Arg::new("signal-info")
                .long("signal-info")
                .help("JSON file generated by instrumentation pass")
                .takes_value(true),
        );
    let diff_cmd = Command::new("diff")
        .about("compare different sets of waveforms")
        .arg(Arg::new("a").long("a").takes_value(true).required(true))
        .arg(Arg::new("a-name").long("a-name").takes_value(true))
        .arg(Arg::new("b").long("b").takes_value(true).required(true))
        .arg(Arg::new("b-name").long("b-name").takes_value(true))
        .arg(Arg::new("base").long("base").takes_value(true))
        .arg(
            Arg::new("include")
                .long("include")
                .short('i')
                .takes_value(true)
                .help("JSON include list for which signals we should track"),
        )
        .arg(
            Arg::new("exclude")
                .long("exclude")
                .short('e')
                .takes_value(true)
                .help("JSON exclude list for which signals we should track"),
        )
        .arg(
            Arg::new("output")
                .long("output")
                .short('o')
                .help("output file for diffed invariants")
                .takes_value(true),
        )
        .arg(
            Arg::new("signal-info")
                .long("signal-info")
                .help("JSON file generated by instrumentation pass")
                .takes_value(true),
        );

    let top_matches = Command::new("invariant-miner")
        .about("mines invariants from VCDs")
        .subcommand_required(true)
        .arg_required_else_help(true)
        .subcommand(extract_cmd)
        .subcommand(mine_cmd)
        .subcommand(diff_cmd)
        .get_matches();

    match top_matches.subcommand() {
        Some(("extract", matches)) => {
            let file_names: Vec<_> = matches
                .values_of("inputs")
                .unwrap()
                .map(|s| s.to_owned())
                .collect();
            let id = matches.value_of("id").expect("expecting id!").to_owned();
            let output = matches
                .value_of("output")
                .map(|o| o.to_owned())
                .unwrap_or(format!("{}.json", &id));
            MinerCmd::Extract(ExtractArgs {
                file_names,
                output,
                id,
            })
        }
        Some(("mine", matches)) => {
            let file_names: Vec<_> = matches
                .values_of("inputs")
                .map(|v| v.map(|s| s.to_owned()).collect())
                .unwrap_or(Vec::new());
            let output: Option<String> = matches.value_of("output").map(|o| o.to_owned());
            let assert_instead_of_cover = matches.is_present("assert");
            let filters = parse_filters(matches, false);
            let max_holes = parse_max_holes(matches);
            let signal_info: Option<String> = matches.value_of("signal-info").map(|o| o.to_owned());
            MinerCmd::Mine(MineArgs {
                file_names,
                output,
                assert_instead_of_cover,
                filters,
                max_holes,
                signal_info,
            })
        }
        Some(("diff", matches)) => {
            let a_filename = matches.value_of("a").unwrap().to_owned();
            let a_name = matches.value_of("a-name").unwrap_or(&a_filename).to_owned();
            let b_filename = matches.value_of("b").unwrap().to_owned();
            let b_name = matches.value_of("b-name").unwrap_or(&b_filename).to_owned();
            let base_filename = matches.value_of("base").map(|s| s.to_owned());
            let filters = parse_filters(matches, true);
            let max_holes = parse_max_holes(matches);
            let output: Option<String> = matches.value_of("output").map(|o| o.to_owned());
            let signal_info: Option<String> = matches.value_of("signal-info").map(|o| o.to_owned());
            MinerCmd::Diff(DiffArgs {
                base_filename,
                a_filename,
                a_name,
                b_filename,
                b_name,
                filters,
                max_holes,
                output,
                signal_info,
            })
        }
        _ => unreachable!("unknown subcommand!"),
    }
}

fn main() {
    match parse_args() {
        MinerCmd::Extract(args) => extract(args),
        MinerCmd::Mine(args) => mine(args),
        MinerCmd::Diff(args) => diff(args),
    }
}

fn extract(args: ExtractArgs) {
    let traces = load_traces(args.id, &args.file_names);
    let start = Instant::now();
    let out = File::create(&args.output).expect("Failed to open output");
    serde_json::to_writer(out, &traces).expect("Failed to write to output file.");
    println!("Wrote traces to {} in {:?}.", &args.output, start.elapsed());
}

fn mine(args: MineArgs) {
    let inputs: Vec<TraceGroup> = args
        .file_names
        .iter()
        .map(|name| {
            let f = File::open(name).expect("Failed to open input file!");
            let tg: TraceGroup =
                serde_json::from_reader(f).expect("Failed to parse input file! (Is it JSON?)");
            tg
        })
        .collect();

    let signal_info = args
        .signal_info
        .map(|f| load_signal_info(&f))
        .unwrap_or_default();

    let trace_group = merge_trace_groups(inputs, &signal_info);

    let props = do_mine(&trace_group, &args.filters, args.max_holes);

    if let Some(out_name) = args.output {
        let mut out = File::create(out_name).expect("Failed to open output");
        write_assertions(&mut out, &props, &trace_group, args.assert_instead_of_cover);
    }
}

fn diff(args: DiffArgs) {
    let base_missing = args
        .base_filename
        .map(|n| load_and_mine(&n, &args.filters, args.max_holes).0)
        .unwrap_or_default();
    let (a_missing, a_traces) = load_and_mine(&args.a_filename, &args.filters, args.max_holes);
    let (b_missing, b_traces) = load_and_mine(&args.b_filename, &args.filters, args.max_holes);

    let (a, b) = if base_missing.is_empty() {
        (a_missing, b_missing)
    } else {
        // if we have a base, we only care about signals that are also missing from the base
        // since the fuzzer/formal tool might have ignored any signals that were already covered
        // by the base
        ((&a_missing & &base_missing), (&b_missing & &base_missing))
    };

    // a and b contain the properties that were **not** found by the set
    // thus
    let a_not_b = &b - &a;
    let b_not_a = &a - &b;

    println!(
        "{} props found by {} but not by {}",
        a_not_b.len(),
        args.a_name,
        args.b_name
    );
    println!(
        "{} props found by {} but not by {}",
        b_not_a.len(),
        args.b_name,
        args.a_name
    );

    if let Some(out_name) = args.output {
        let signal_info = args
            .signal_info
            .map(|f| load_signal_info(&f))
            .unwrap_or_default();
        let signal_names = load_signal_names(&args.a_filename);

        let mut out = File::create(out_name).expect("Failed to open output");
        write_assertion_header(&mut out, &signal_names);
        write_covered_by(
            &mut out,
            &signal_names,
            &signal_info,
            &a_traces,
            &b_traces,
            &a_not_b,
        );
        write_covered_by(
            &mut out,
            &signal_names,
            &signal_info,
            &b_traces,
            &a_traces,
            &b_not_a,
        );
        write_assertion_footer(&mut out);
    }
}

#[derive(Serialize, Deserialize)]
struct SignalInfo {
    name: String,
    expr: String,
}

fn load_signal_info(filename: &str) -> HashMap<String, String> {
    let f = File::open(filename).expect("Failed to signal info file!");
    let signals: Vec<SignalInfo> =
        serde_json::from_reader(f).expect("Failed to parse signal info file!");
    HashMap::from_iter(signals.into_iter().map(|s| (s.name, s.expr)))
}

fn write_covered_by(
    out: &mut File,
    signal_names: &[String],
    signal_info: &HashMap<String, String>,
    a_traces: &TraceGroup,
    b_traces: &TraceGroup,
    a_not_b: &HashSet<Prop>,
) {
    writeln!(out).unwrap();
    writeln!(
        out,
        "  //-------------------------------------------------------------------"
    )
    .unwrap();
    writeln!(
        out,
        "  // {} props falsified by {} but not by {}",
        a_not_b.len(),
        a_traces.id,
        b_traces.id
    )
    .unwrap();
    writeln!(out).unwrap();

    let mut ordered: Vec<_> = a_not_b.iter().collect();
    ordered.sort();

    for prop in ordered.iter() {
        let expr = prop_to_verilog(prop, signal_names);
        // find out which exact trace in A found a violation for this property
        match find_violating_trace(prop, a_traces) {
            Some(violation) => {
                writeln!(
                    out,
                    "    // falsified in {} after {} cycles",
                    violation.trace, violation.cycle
                )
                .unwrap();
            }
            None => unreachable!(
                "Property: {}. No violating trace found in {}. Internal error.",
                expr, a_traces.id
            ),
        }
        let comment = prop_to_human_readable(prop, signal_names, signal_info);
        writeln!(out, "    // {}", comment).unwrap();
        write_cover_violation(out, &expr, true);
    }
}

fn load_signal_names(filename: &str) -> Vec<String> {
    let f = File::open(filename).expect("Failed to open input file!");
    let trace_group: TraceGroup =
        serde_json::from_reader(f).expect("Failed to parse input file! (Is it JSON?)");
    trace_group.signal_names
}

fn load_and_mine(
    filename: &str,
    filters: &SignalFilters,
    max_holes: TemplateSize,
) -> (HashSet<Prop>, TraceGroup) {
    println!("Loading and mining {}", filename);
    let f = File::open(filename).expect("Failed to open input file!");
    let trace_group: TraceGroup =
        serde_json::from_reader(f).expect("Failed to parse input file! (Is it JSON?)");
    let props = do_mine(&trace_group, filters, max_holes);
    let p = HashSet::from_iter(props.into_iter());
    println!();
    (p, trace_group)
}

fn merge_trace_groups(tgs: Vec<TraceGroup>, signal_info: &HashMap<String, String>) -> TraceGroup {
    if tgs.is_empty() {
        // no traces provided which means we need to fake one with the signal info
        assert!(
            !signal_info.is_empty(),
            "You need to either provide signal information or at least one trace!"
        );

        let mut signal_names: Vec<String> = signal_info.keys().cloned().collect();
        signal_names.sort();

        TraceGroup {
            id: "".to_string(),
            traces: Vec::new(),
            signal_names,
            aliases: Vec::new(),
        }
    } else if tgs.len() == 1 {
        tgs.into_iter().next().unwrap()
    } else {
        let aligned = align_trace_groups(tgs);
        let id = aligned
            .iter()
            .map(|g| g.id.clone())
            .collect::<Vec<_>>()
            .join("+");
        let signal_names = aligned.first().unwrap().signal_names.clone();
        let aliases = aligned.first().unwrap().aliases.clone();
        let traces: Vec<_> = aligned.into_iter().flat_map(|g| g.traces).collect();
        TraceGroup {
            id,
            traces,
            signal_names,
            aliases,
        }
    }
}

/// ensures that all trace groups have the same indexing scheme
fn align_trace_groups(tgs: Vec<TraceGroup>) -> Vec<TraceGroup> {
    let first = tgs.first().unwrap();
    // check invariant instead of actually generating it
    for tg in tgs.iter() {
        assert_eq!(tg.signal_names, first.signal_names);
        assert_eq!(tg.aliases, first.aliases);
    }
    tgs // TODO!
}

fn write_assertion_header(out: &mut File, signal_names: &[String]) {
    writeln!(out, "// properties generated by our invariant miner").unwrap();
    writeln!(out, "module SignalTracker(").unwrap();
    writeln!(out, "  input   clock,").unwrap();
    write!(out, "  input   reset").unwrap();
    for name in signal_names.iter() {
        write!(out, ",\n  input {}", name).unwrap();
    }
    // TODO: iterate over all signal names from trace group!
    writeln!(out, "\n);").unwrap();
    writeln!(out, "  always @(posedge clock) begin").unwrap();
}

fn write_assertion_footer(out: &mut File) {
    writeln!(out, "  end").unwrap();
    writeln!(out, "endmodule").unwrap();
}

fn write_assertions(
    out: &mut File,
    props: &[Prop],
    trace_group: &TraceGroup,
    assert_instead_of_cover: bool,
) {
    write_assertion_header(out, &trace_group.signal_names);

    for prop in props {
        let expr = prop_to_verilog(prop, &trace_group.signal_names);
        write_cover_violation(out, &expr, assert_instead_of_cover);
    }

    write_assertion_footer(out);
}

fn write_cover_violation(out: &mut File, expr: &str, assert_instead_of_cover: bool) {
    writeln!(out, "    if (~reset) begin").unwrap();
    if assert_instead_of_cover {
        writeln!(out, "      assert({});", expr).unwrap();
    } else {
        // we are trying to cover the negation of the assertion
        writeln!(out, "      cover(~({}));", expr).unwrap();
    }
    writeln!(out, "    end").unwrap();
}
